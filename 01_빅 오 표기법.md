# 빅 오 표기법



## 복잡도

- 시간복잡도 - 실행시간 의미
- 공각복잡도 - 컴퓨터 메모리 의미



## 표기법

- 알고리즘의 효율성을 평가할 때 사용
- 종류
  - Big-O (빅-오) - 실행시간 최대 측정
  - Theta (세타) - 실행시간의 최소 및 최대 시간 측정
  - Big-Omega (빅-오메가) - 실행시간 최소 측정


- 빅오 표기법
  - O(1) - 최선 (상수) / 입력량과 무관하게 실행시간 일정
  - O(log n) -  입력량이 증가해도 기하급수적으로 실행시간 증가하지 않음 (그래프 참고)
  - O(n) -  입력량에 비례해서 실행시간 증가
  - O(n log n) - 이 정도면 훌륭함
  - O(n^2) - n제곱까진 괜찮다. 
  - O(n^3) - 아주 나쁜 경우지만, 괜찮다. (마지노선)
  -  O(2n) - 적극적으로 피해라.
  - O(n!) - 적극적으로 피해라.
- 참고
  - UPDOWN GAME : O(n), O(log n) [1... 50.... 100]
    - O(n) - 1부터 100까지 다 불러 찾는 방법
    - O(log n) - 50을 부르고 반절씩 잘라 나가면서 찾는 방법

## 예시

- O(n): for문 (i++ )
- On2): 이중 for문 (i++)
- O(n3): 삼중 for문 (i++)
- O(log n): for문의 i가 1, 2, 3... 순차적이 아니 라 곱하기 또는 나누기로 배수 등 .. 절반이 되는 상황일때 (in)
- O(n log n): 이중 for문 중에 바깥 for문인 i는 n 이고(i++ ), 안쪽 이중 for문의 j가 j * 2인경우 ( 바깥 for문의 n과 안쪽 for문의의 값이 2인 log 가 합쳐져 nlog(n)이 됨)

- O(n), O(nlogn), O(n2) 뭐가 제일 좋나요?
  - n이 30보다 작으면 크게 차이 나지 않고, 오히려 O(n^2)이 더 좋을 수 있음
  - 알고리즘 같은 경우는, 숫자가 충분히 클 때 !! 시간복잡도의 효율을 따질 수 있음 n뒤에 붙는 수가 작을 수록 더 빠름